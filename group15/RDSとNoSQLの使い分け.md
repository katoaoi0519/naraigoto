## RDSとNoSQLの使い分けガイド（AWS想定）

- **目的**: プロダクト要件に応じたデータストア選定の指針を短時間で判断できるように整理
- **前提**: AWSマネージドを前提。RDSは Aurora/MySQL/PostgreSQL、NoSQLは主に DynamoDB（ドキュメント系は Amazon DocumentDB も候補）

### TL;DR（まずはここだけ）
- **複雑な結合/柔軟なSQL/強整合の複合トランザクションが中核** → RDS（Aurora）
- **予測困難な高スループット/低レイテンシ/水平スケールが中核** → DynamoDB
- **レポーティング/BI/アドホック分析が多い** → RDS +（必要なら）別途分析系へ複製
- **アクセスパターンが明確でキー設計ができる** → DynamoDB が強い
- **どちらも必要** → ポリグロット永続化（両採用）

### 比較表
| 観点 | RDS（Aurora/MySQL/PostgreSQL） | NoSQL（DynamoDB/DocumentDB 等） | メモ |
|---|---|---|---|
| データモデル | リレーショナル（正規化） | キー値/ドキュメント/ワイドカラム | DynamoDB は単一テーブル設計が基本 |
| クエリ | SQL、JOIN/集計/副問い合わせ | 主キー/二次索引で高速、スキャンは重い | アドホック性はRDSが強い |
| トランザクション | ACID、複数行/複数テーブルに強い | パーティション内で限定的（DynamoDBのTxはあるが範囲は限定） | 複雑TxならRDS |
| 一貫性 | 強整合（設定により） | 最終的整合が基本、強整合読みも可（DynamoDB） | R/Wパターンで選択 |
| スケール | 垂直/リーダーレプリカ水平読み | 水平スケール前提（自動パーティショニング） | 爆発的スループットはNoSQL |
| レイテンシ | ミリ秒〜 | サブミリ秒〜ミリ秒 | 超低レイテンシはNoSQLが得意 |
| 運用 | バージョン/メンテ/チューニング必要 | フルマネージドで運用負荷低 | 要件とチーム体制で判断 |
| コスト | インスタンス+ストレージ+IO | RCU/WCU+ストレージ（オンデマンド/プロビジョンド） | アクセスパターンで大きく変動 |
| スキーマ | 厳密（変更は影響大） | スキーマレス（規約設計が重要） | スキーマ進化が激しいならNoSQL有利 |
| バックアップ/DR | 自動バックアップ/PITR/クロスリージョン | PITR/Global Tables 等 | 双方十分だが方式が異なる |
| 典型落とし穴 | スケール限界/ロック競合 | ホットパーティション/全表スキャン | 設計の解像度が重要 |

### 代表ユースケース
- **RDS 向き**
  - 多数の JOIN、複雑な集計/アドホックSQLが必要
  - 強整合な複合トランザクション（例: 注文→在庫→決済の一括整合）
  - 参照整合性（外部キー）を厳格に担保したい
  - BI/レポーティング、運用SQLの頻度が高い
- **NoSQL（DynamoDB）向き**
  - 明確なアクセスパターンでキー設計可能（単一テーブル設計）
  - 超高スループット/低レイテンシ、可用性/スケールを最優先
  - セッション、イベントログ、タイムライン、ショッピングカート、カタログ
  - スキーマ進化が激しく柔軟性が必要

### 判断フロー（簡易）
1. 主要ユースケースで JOIN を多用し、アドホックSQLが多いか？ → はい: RDS
2. 要求スループットは非常に高く、低レイテンシが必須か？ → はい: DynamoDB
3. 強整合な複合トランザクション（複数エンティティ跨ぎ）が中核か？ → はい: RDS
4. アクセスパターンが固定的/明確で、パーティションキー設計が可能か？ → はい: DynamoDB
5. 双方の要件が強い → 重要データはRDS、読み/高スループットはDynamoDB などの併用

### AWSでの実装Tips
- **RDS（Aurora推奨）**
  - マルチAZ/リーダーレプリカ、Aurora Serverless v2 で自動スケール
  - 接続プールは RDS Proxy、長いTxやスキャンの削減、適切な索引設計
  - バックアップ/PITR/クロスリージョンレプリカ、SQL監視（Performance Insights）
- **DynamoDB**
  - アクセスパターン先行設計（PK/SK、ソートキー、GSI、LSI）
  - ホットパーティション回避（高カーディナリティ、負荷分散キー）
  - Streams + Lambda で非同期ワークフロー、TTLでデータ寿命管理、DAXでキャッシュ
  - グローバルテーブルで多リージョン可用性

### コストと運用の考え方
- **RDS**: インスタンスサイズでベースコストが発生。I/O とストレージで増分。ピーク時のみ一時的にスケールアップする場合は Serverless v2 を検討。
- **DynamoDB**: アクセス数（RCU/WCU）が主コスト。オンデマンドはシンプルだが高頻度では割高。安定ワークロードはプロビジョンド+Auto Scaling。
- **共通**: 監視（スロットル/遅延/エラー率）、バックアップ、障害設計（AZ/リージョン）を事前に定義。

### アンチパターン（避けたい例）
- DynamoDB で頻繁な全表スキャンや非効率な多対多を多用（アクセスパターン未定義）
- RDS に横方向の無制限スケールを期待（設計/分割なしでは限界が早い）
- NoSQL の「スキーマレス」を理由にデータ規約を定めない（運用で破綻）
- ホットパーティションを放置（特定キーに集中する設計）

### 併用（ポリグロット永続化）の指針
- 書き込みの真正性・参照整合性が重要なコアは RDS をソース・オブ・トゥルースに
- 高スループット読み取りや柔軟スキーマは DynamoDB に投影（イベント駆動で非同期整合）
- 例: 受注台帳は RDS、ユーザーのフィード/検索インデックスは DynamoDB/Elasticsearch 等

### 例: 典型要件からの選定例
- 「注文-在庫-決済を一括確定し、月次で複雑な会計レポート」→ RDS（+ 分析系へ複製）
- 「ユーザータイムラインと通知を低遅延で大量配信」→ DynamoDB（+ Streams/DAX）
- 「商品カタログを多軸で検索、カートは低遅延」→ 併用（RDSで整合、DynamoDBで配信）

### マイグレーションの進め方（既存RDS→DynamoDB の例）
1. アクセスパターンの棚卸し（上位3〜5を定義）
2. エンティティ関係をデノーマライズして単一テーブル設計に落とす
3. PK/SK/GSI を設計し、ホットパーティションを検証
4. AWS DMS 等でバックフィル、二重書き込みで段階移行
5. カットオーバー後に読み取りを段階的に切替、監視で回帰

### セキュリティ/コンプライアンス
- KMS による暗号化（RDS/DynamoDB 共通）、VPC/PrivateLink、IAM/ロール最小権限
- Secrets Manager（RDS）、PITR、監査ログ（CloudTrail/CloudWatch）

### クイックチェックリスト（着手前に確認）
- 主要アクセスパターンを3つ以上、文として説明できる
- 必要な一貫性レベル（強整合/最終的整合）を合意
- トランザクション境界（どの単位で不可分に更新するか）を合意
- 目標スループット/レイテンシSLO、データ量/成長率を見積もり
- スキーマ変更頻度と体制、運用負荷の許容度を確認

### 参考リンク
- [AWS RDS（Aurora）](https://docs.aws.amazon.com/aurora/latest/userguide/what-is-aurora.html)
- [AWS DynamoDB ベストプラクティス](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
- [DynamoDB 単一テーブル設計ガイド](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-general-nosql-design.html)
- [AWS DMS（移行）](https://docs.aws.amazon.com/dms/latest/userguide/Welcome.html)
